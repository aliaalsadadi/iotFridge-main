{"version":3,"file":"ort-common.min.js","mappings":"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","sources":["webpack://ort/webpack/universalModuleDefinition","webpack://ort/webpack/bootstrap","webpack://ort/webpack/runtime/define property getters","webpack://ort/webpack/runtime/hasOwnProperty shorthand","webpack://ort/webpack/runtime/make namespace object","webpack://ort/./lib/backend-impl.ts","webpack://ort/./lib/env.ts","webpack://ort/./lib/env-impl.ts","webpack://ort/./lib/tensor-impl.ts","webpack://ort/./lib/tensor.ts","webpack://ort/./lib/inference-session-impl.ts","webpack://ort/./lib/inference-session.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ort\"] = factory();\n\telse\n\t\troot[\"ort\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Backend} from './backend';\n\ninterface BackendInfo {\n  backend: Backend;\n  priority: number;\n\n  initPromise?: Promise<void>;\n  initialized?: boolean;\n  aborted?: boolean;\n}\n\nconst backends: {[name: string]: BackendInfo} = {};\nconst backendsSortedByPriority: string[] = [];\n\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @internal\n */\nexport const registerBackend = (name: string, backend: Backend, priority: number): void => {\n  if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {\n    const currentBackend = backends[name];\n    if (currentBackend === undefined) {\n      backends[name] = {backend, priority};\n    } else if (currentBackend.priority > priority) {\n      // same name is already registered with a higher priority. skip registeration.\n      return;\n    } else if (currentBackend.priority === priority) {\n      if (currentBackend.backend !== backend) {\n        throw new Error(`cannot register backend \"${name}\" using priority ${priority}`);\n      }\n    }\n\n    if (priority >= 0) {\n      const i = backendsSortedByPriority.indexOf(name);\n      if (i !== -1) {\n        backendsSortedByPriority.splice(i, 1);\n      }\n\n      for (let i = 0; i < backendsSortedByPriority.length; i++) {\n        if (backends[backendsSortedByPriority[i]].priority <= priority) {\n          backendsSortedByPriority.splice(i, 0, name);\n          return;\n        }\n      }\n      backendsSortedByPriority.push(name);\n    }\n    return;\n  }\n\n  throw new TypeError('not a valid backend');\n};\n\n/**\n * Resolve backend by specified hints.\n *\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\n * @returns a promise that resolves to the backend.\n *\n * @internal\n */\nexport const resolveBackend = async(backendHints: readonly string[]): Promise<Backend> => {\n  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n  const errors = [];\n  for (const backendName of backendNames) {\n    const backendInfo = backends[backendName];\n    if (backendInfo) {\n      if (backendInfo.initialized) {\n        return backendInfo.backend;\n      } else if (backendInfo.aborted) {\n        continue;  // current backend is unavailable; try next\n      }\n\n      const isInitializing = !!backendInfo.initPromise;\n      try {\n        if (!isInitializing) {\n          backendInfo.initPromise = backendInfo.backend.init();\n        }\n        await backendInfo.initPromise;\n        backendInfo.initialized = true;\n        return backendInfo.backend;\n      } catch (e) {\n        if (!isInitializing) {\n          errors.push({name: backendName, err: e});\n        }\n        backendInfo.aborted = true;\n      } finally {\n        delete backendInfo.initPromise;\n      }\n    }\n  }\n\n  throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {EnvImpl} from './env-impl';\n\nexport declare namespace Env {\n  export type WasmPrefixOrFilePaths = string|{\n    /* eslint-disable @typescript-eslint/naming-convention */\n    'ort-wasm.wasm'?: string;\n    'ort-wasm-threaded.wasm'?: string;\n    'ort-wasm-simd.wasm'?: string;\n    'ort-wasm-simd-threaded.wasm'?: string;\n    /* eslint-enable @typescript-eslint/naming-convention */\n  };\n  export interface WebAssemblyFlags {\n    /**\n     * set or get number of thread(s). If omitted or set to 0, number of thread(s) will be determined by system. If set\n     * to 1, no worker thread will be spawned.\n     *\n     * This setting is available only when WebAssembly multithread feature is available in current context.\n     *\n     * @defaultValue `0`\n     */\n    numThreads?: number;\n\n    /**\n     * set or get a boolean value indicating whether to enable SIMD. If set to false, SIMD will be forcely disabled.\n     *\n     * This setting is available only when WebAssembly SIMD feature is available in current context.\n     *\n     * @defaultValue `true`\n     */\n    simd?: boolean;\n\n    /**\n     * Set or get a number specifying the timeout for initialization of WebAssembly backend, in milliseconds. A zero\n     * value indicates no timeout is set.\n     *\n     * @defaultValue `0`\n     */\n    initTimeout?: number;\n\n    /**\n     * Set a custom URL prefix to the .wasm files or a set of overrides for each .wasm file. The override path should be\n     * an absolute path.\n     */\n    wasmPaths?: WasmPrefixOrFilePaths;\n\n    /**\n     * Set or get a boolean value indicating whether to proxy the execution of main thread to a worker thread.\n     *\n     * @defaultValue `false`\n     */\n    proxy?: boolean;\n  }\n\n  export interface WebGLFlags {\n    /**\n     * Set or get the WebGL Context ID (webgl or webgl2).\n     *\n     * @defaultValue `'webgl2'`\n     */\n    contextId?: 'webgl'|'webgl2';\n    /**\n     * Set or get the maximum batch size for matmul. 0 means to disable batching.\n     *\n     * @deprecated\n     */\n    matmulMaxBatchSize?: number;\n    /**\n     * Set or get the texture cache mode.\n     *\n     * @defaultValue `'full'`\n     */\n    textureCacheMode?: 'initializerOnly'|'full';\n    /**\n     * Set or get the packed texture mode\n     *\n     * @defaultValue `false`\n     */\n    pack?: boolean;\n    /**\n     * Set or get whether enable async download.\n     *\n     * @defaultValue `false`\n     */\n    async?: boolean;\n  }\n\n  export interface WebGpuFlags {\n    profilingMode?: 'off'|'default';\n  }\n}\n\nexport interface Env {\n  /**\n   * set the severity level for logging.\n   *\n   * @defaultValue `'warning'`\n   */\n  logLevel?: 'verbose'|'info'|'warning'|'error'|'fatal';\n  /**\n   * Indicate whether run in debug mode.\n   *\n   * @defaultValue `false`\n   */\n  debug?: boolean;\n\n  /**\n   * Represent a set of flags for WebAssembly\n   */\n  wasm: Env.WebAssemblyFlags;\n\n  /**\n   * Represent a set of flags for WebGL\n   */\n  webgl: Env.WebGLFlags;\n\n  /**\n   * Represent a set of flags for WebGPU\n   */\n  webgpu: Env.WebGpuFlags;\n\n  [name: string]: unknown;\n}\n\n/**\n * Represent a set of flags as a global singleton.\n */\nexport const env: Env = new EnvImpl();\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Env} from './env';\n\ntype LogLevelType = Env['logLevel'];\nexport class EnvImpl implements Env {\n  constructor() {\n    this.wasm = {};\n    this.webgl = {};\n    this.webgpu = {};\n    this.logLevelInternal = 'warning';\n  }\n\n  // TODO standadize the getter and setter convention in env for other fields.\n  set logLevel(value: LogLevelType) {\n    if (value === undefined) {\n      return;\n    }\n    if (typeof value !== 'string' || ['verbose', 'info', 'warning', 'error', 'fatal'].indexOf(value) === -1) {\n      throw new Error(`Unsupported logging level: ${value}`);\n    }\n    this.logLevelInternal = value;\n  }\n  get logLevel(): LogLevelType {\n    return this.logLevelInternal;\n  }\n\n  debug?: boolean;\n\n  wasm: Env.WebAssemblyFlags;\n  webgl: Env.WebGLFlags;\n  webgpu: Env.WebGpuFlags;\n\n  [name: string]: unknown;\n\n  private logLevelInternal: Required<LogLevelType>;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor as TensorInterface, TensorFromImageOptions, TensorToImageDataOptions} from './tensor';\n\ntype TensorType = TensorInterface.Type;\ntype TensorDataType = TensorInterface.DataType;\n\ntype SupportedTypedArrayConstructors = Float32ArrayConstructor|Uint8ArrayConstructor|Int8ArrayConstructor|\n    Uint16ArrayConstructor|Int16ArrayConstructor|Int32ArrayConstructor|BigInt64ArrayConstructor|Uint8ArrayConstructor|\n    Float64ArrayConstructor|Uint32ArrayConstructor|BigUint64ArrayConstructor;\ntype SupportedTypedArray = InstanceType<SupportedTypedArrayConstructors>;\n\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map<string, SupportedTypedArrayConstructors>([\n  ['float32', Float32Array],\n  ['uint8', Uint8Array],\n  ['int8', Int8Array],\n  ['uint16', Uint16Array],\n  ['int16', Int16Array],\n  ['int32', Int32Array],\n  ['bool', Uint8Array],\n  ['float64', Float64Array],\n  ['uint32', Uint32Array],\n]);\n\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map<SupportedTypedArrayConstructors, TensorType>([\n  [Float32Array, 'float32'],\n  [Uint8Array, 'uint8'],\n  [Int8Array, 'int8'],\n  [Uint16Array, 'uint16'],\n  [Int16Array, 'int16'],\n  [Int32Array, 'int32'],\n  [Float64Array, 'float64'],\n  [Uint32Array, 'uint32'],\n]);\n\n// the following code allows delaying execution of BigInt checking. This allows lazy initialization for\n// NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP and NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, which allows BigInt polyfill\n// if available.\nlet isBigIntChecked = false;\nconst checkBigInt = () => {\n  if (!isBigIntChecked) {\n    isBigIntChecked = true;\n    const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';\n    const isBigUint64ArrayAvailable =\n        typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';\n\n    if (isBigInt64ArrayAvailable) {\n      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\n      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\n    }\n    if (isBigUint64ArrayAvailable) {\n      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\n      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\n    }\n  }\n};\n\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */\nconst calculateSize = (dims: readonly unknown[]): number => {\n  let size = 1;\n  for (let i = 0; i < dims.length; i++) {\n    const dim = dims[i];\n    if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\n      throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n    }\n    if (dim < 0) {\n      throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n    }\n    size *= dim;\n  }\n  return size;\n};\n\nexport class Tensor implements TensorInterface {\n  // #region constructors\n  constructor(type: TensorType, data: TensorDataType|readonly number[]|readonly boolean[], dims?: readonly number[]);\n  constructor(data: TensorDataType|readonly boolean[], dims?: readonly number[]);\n  constructor(\n      arg0: TensorType|TensorDataType|readonly boolean[], arg1?: TensorDataType|readonly number[]|readonly boolean[],\n      arg2?: readonly number[]) {\n    checkBigInt();\n\n    let type: TensorType;\n    let data: TensorDataType;\n    let dims: typeof arg1|typeof arg2;\n    // check whether arg0 is type or data\n    if (typeof arg0 === 'string') {\n      //\n      // Override: constructor(type, data, ...)\n      //\n      type = arg0;\n      dims = arg2;\n      if (arg0 === 'string') {\n        // string tensor\n        if (!Array.isArray(arg1)) {\n          throw new TypeError('A string tensor\\'s data must be a string array.');\n        }\n        // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n        // error will be populated at inference\n        data = arg1;\n      } else {\n        // numeric tensor\n        const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n        if (typedArrayConstructor === undefined) {\n          throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n        }\n        if (Array.isArray(arg1)) {\n          // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces\n          // incorrect results.\n          // 'typedArrayConstructor' should be one of the typed array prototype objects.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          data = (typedArrayConstructor as any).from(arg1);\n        } else if (arg1 instanceof typedArrayConstructor) {\n          data = arg1;\n        } else {\n          throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n        }\n      }\n    } else {\n      //\n      // Override: constructor(data, ...)\n      //\n      dims = arg1;\n      if (Array.isArray(arg0)) {\n        // only boolean[] and string[] is supported\n        if (arg0.length === 0) {\n          throw new TypeError('Tensor type cannot be inferred from an empty array.');\n        }\n        const firstElementType = typeof arg0[0];\n        if (firstElementType === 'string') {\n          type = 'string';\n          data = arg0;\n        } else if (firstElementType === 'boolean') {\n          type = 'bool';\n          // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n          // wrong type. We use 'as any' to make it happy.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          data = Uint8Array.from(arg0 as any[]);\n        } else {\n          throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n        }\n      } else {\n        // get tensor type from TypedArray\n        const mappedType =\n            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor as SupportedTypedArrayConstructors);\n        if (mappedType === undefined) {\n          throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n        }\n        type = mappedType;\n        data = arg0 as SupportedTypedArray;\n      }\n    }\n\n    // type and data is processed, now processing dims\n    if (dims === undefined) {\n      // assume 1-D tensor if dims omitted\n      dims = [data.length];\n    } else if (!Array.isArray(dims)) {\n      throw new TypeError('A tensor\\'s dims must be a number array');\n    }\n\n    // perform check\n    const size = calculateSize(dims);\n    if (size !== data.length) {\n      throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);\n    }\n\n    this.dims = dims as readonly number[];\n    this.type = type;\n    this.data = data;\n    this.size = size;\n  }\n  // #endregion\n  /**\n   * Create a new tensor object from image object\n   *\n   * @param buffer - Extracted image buffer data - assuming RGBA format\n   * @param imageFormat - input image configuration - required configurations height, width, format\n   * @param tensorFormat - output tensor configuration - Default is RGB format\n   */\n  private static bufferToTensor(buffer: Uint8ClampedArray|undefined, options: TensorFromImageOptions): Tensor {\n    if (buffer === undefined) {\n      throw new Error('Image buffer must be defined');\n    }\n    if (options.height === undefined || options.width === undefined) {\n      throw new Error('Image height and width must be defined');\n    }\n    if (options.tensorLayout === 'NHWC') {\n      throw new Error('NHWC Tensor layout is not supported yet');\n    }\n\n    const {height, width} = options;\n\n    const norm = options.norm ?? {mean: 255, bias: 0};\n    let normMean: [number, number, number, number];\n    let normBias: [number, number, number, number];\n\n    if (typeof (norm.mean) === 'number') {\n      normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n    } else {\n      normMean = [norm.mean![0], norm.mean![1], norm.mean![2], norm.mean![3] ?? 255];\n    }\n\n    if (typeof (norm.bias) === 'number') {\n      normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n    } else {\n      normBias = [norm.bias![0], norm.bias![1], norm.bias![2], norm.bias![3] ?? 0];\n    }\n\n    const inputformat = options.bitmapFormat !== undefined ? options.bitmapFormat : 'RGBA';\n    // default value is RGBA since imagedata and HTMLImageElement uses it\n\n    const outputformat = options.tensorFormat !== undefined ?\n        (options.tensorFormat !== undefined ? options.tensorFormat : 'RGB') :\n        'RGB';\n    const stride = height * width;\n    const float32Data = outputformat === 'RGBA' ? new Float32Array(stride * 4) : new Float32Array(stride * 3);\n\n    // Default pointer assignments\n    let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n    let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n\n    // Updating the pointer assignments based on the input image format\n    if (inputformat === 'RGB') {\n      step = 3;\n      rImagePointer = 0;\n      gImagePointer = 1;\n      bImagePointer = 2;\n      aImagePointer = -1;\n    }\n\n    // Updating the pointer assignments based on the output tensor format\n    if (outputformat === 'RGBA') {\n      aTensorPointer = stride * 3;\n    } else if (outputformat === 'RBG') {\n      rTensorPointer = 0;\n      bTensorPointer = stride;\n      gTensorPointer = stride * 2;\n    } else if (outputformat === 'BGR') {\n      bTensorPointer = 0;\n      gTensorPointer = stride;\n      rTensorPointer = stride * 2;\n    }\n\n    for (let i = 0; i < stride;\n         i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {\n      float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];\n      float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];\n      float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];\n      if (aTensorPointer !== -1 && aImagePointer !== -1) {\n        float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];\n      }\n    }\n\n    // Float32Array -> ort.Tensor\n    const outputTensor = outputformat === 'RGBA' ? new Tensor('float32', float32Data, [1, 4, height, width]) :\n                                                   new Tensor('float32', float32Data, [1, 3, height, width]);\n    return outputTensor;\n  }\n\n  // #region factory\n  static async fromImage(imageData: ImageData, options?: TensorFromImageOptions): Promise<Tensor>;\n  static async fromImage(imageElement: HTMLImageElement, options?: TensorFromImageOptions): Promise<Tensor>;\n  static async fromImage(bitmap: ImageBitmap, options: TensorFromImageOptions): Promise<Tensor>;\n  static async fromImage(urlSource: string, options?: TensorFromImageOptions): Promise<Tensor>;\n\n  static async fromImage(image: ImageData|HTMLImageElement|ImageBitmap|string, options?: TensorFromImageOptions):\n      Promise<Tensor> {\n    // checking the type of image object\n    const isHTMLImageEle = typeof (HTMLImageElement) !== 'undefined' && image instanceof HTMLImageElement;\n    const isImageDataEle = typeof (ImageData) !== 'undefined' && image instanceof ImageData;\n    const isImageBitmap = typeof (ImageBitmap) !== 'undefined' && image instanceof ImageBitmap;\n    const isString = typeof image === 'string';\n\n    let data: Uint8ClampedArray|undefined;\n    let tensorConfig: TensorFromImageOptions = options ?? {};\n\n    // filling and checking image configuration options\n    if (isHTMLImageEle) {\n      // HTMLImageElement - image object - format is RGBA by default\n      const canvas = document.createElement('canvas');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      const pixels2DContext = canvas.getContext('2d');\n\n      if (pixels2DContext != null) {\n        let height = image.height;\n        let width = image.width;\n        if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {\n          height = options.resizedHeight;\n          width = options.resizedWidth;\n        }\n\n        if (options !== undefined) {\n          tensorConfig = options;\n          if (options.tensorFormat !== undefined) {\n            throw new Error('Image input config format must be RGBA for HTMLImageElement');\n          } else {\n            tensorConfig.tensorFormat = 'RGBA';\n          }\n          if (options.height !== undefined && options.height !== height) {\n            throw new Error('Image input config height doesn\\'t match HTMLImageElement height');\n          } else {\n            tensorConfig.height = height;\n          }\n          if (options.width !== undefined && options.width !== width) {\n            throw new Error('Image input config width doesn\\'t match HTMLImageElement width');\n          } else {\n            tensorConfig.width = width;\n          }\n        } else {\n          tensorConfig.tensorFormat = 'RGBA';\n          tensorConfig.height = height;\n          tensorConfig.width = width;\n        }\n\n        pixels2DContext.drawImage(image, 0, 0);\n        data = pixels2DContext.getImageData(0, 0, width, height).data;\n      } else {\n        throw new Error('Can not access image data');\n      }\n\n    } else if (isImageDataEle) {\n      // ImageData - image object - format is RGBA by default\n      const format = 'RGBA';\n      let height: number;\n      let width: number;\n\n      if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {\n        height = options.resizedHeight;\n        width = options.resizedWidth;\n      } else {\n        height = image.height;\n        width = image.width;\n      }\n\n      if (options !== undefined) {\n        tensorConfig = options;\n        if (options.bitmapFormat !== undefined && options.bitmapFormat !== format) {\n          throw new Error('Image input config format must be RGBA for ImageData');\n        } else {\n          tensorConfig.bitmapFormat = 'RGBA';\n        }\n      } else {\n        tensorConfig.bitmapFormat = 'RGBA';\n      }\n\n      tensorConfig.height = height;\n      tensorConfig.width = width;\n\n      if (options !== undefined) {\n        const tempCanvas = document.createElement('canvas');\n\n        tempCanvas.width = width;\n        tempCanvas.height = height;\n\n        const pixels2DContext = tempCanvas.getContext('2d');\n\n        if (pixels2DContext != null) {\n          pixels2DContext.putImageData(image, 0, 0);\n          data = pixels2DContext.getImageData(0, 0, width, height).data;\n        } else {\n          throw new Error('Can not access image data');\n        }\n      } else {\n        data = image.data;\n      }\n\n    } else if (isImageBitmap) {\n      // ImageBitmap - image object - format must be provided by user\n      if (options === undefined) {\n        throw new Error('Please provide image config with format for Imagebitmap');\n      }\n      if (options.bitmapFormat !== undefined) {\n        throw new Error('Image input config format must be defined for ImageBitmap');\n      }\n\n      const pixels2DContext = document.createElement('canvas').getContext('2d');\n\n      if (pixels2DContext != null) {\n        const height = image.height;\n        const width = image.width;\n        pixels2DContext.drawImage(image, 0, 0, width, height);\n        data = pixels2DContext.getImageData(0, 0, width, height).data;\n        if (options !== undefined) {\n          // using square brackets to avoid TS error - type 'never'\n          if (options.height !== undefined && options.height !== height) {\n            throw new Error('Image input config height doesn\\'t match ImageBitmap height');\n          } else {\n            tensorConfig.height = height;\n          }\n          // using square brackets to avoid TS error - type 'never'\n          if (options.width !== undefined && options.width !== width) {\n            throw new Error('Image input config width doesn\\'t match ImageBitmap width');\n          } else {\n            tensorConfig.width = width;\n          }\n        } else {\n          tensorConfig.height = height;\n          tensorConfig.width = width;\n        }\n        return Tensor.bufferToTensor(data, tensorConfig);\n      } else {\n        throw new Error('Can not access image data');\n      }\n\n    } else if (isString) {\n      return new Promise((resolve, reject) => {\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        if (!image || !context) {\n          return reject();\n        }\n        const newImage = new Image();\n        newImage.crossOrigin = 'Anonymous';\n        newImage.src = image;\n        newImage.onload = () => {\n          canvas.width = newImage.width;\n          canvas.height = newImage.height;\n          context.drawImage(newImage, 0, 0, canvas.width, canvas.height);\n          const img = context.getImageData(0, 0, canvas.width, canvas.height);\n          if (options !== undefined) {\n            if (options.height !== undefined && options.height !== canvas.height) {\n              throw new Error('Image input config height doesn\\'t match height');\n            } else {\n              tensorConfig.height = canvas.height;\n            }\n            if (options.width !== undefined && options.width !== canvas.width) {\n              throw new Error('Image input config width doesn\\'t match width');\n            } else {\n              tensorConfig.width = canvas.width;\n            }\n          } else {\n            tensorConfig.height = canvas.height;\n            tensorConfig.width = canvas.width;\n          }\n          resolve(Tensor.bufferToTensor(img.data, tensorConfig));\n        };\n      });\n    } else {\n      throw new Error('Input data provided is not supported - aborted tensor creation');\n    }\n\n    if (data !== undefined) {\n      return Tensor.bufferToTensor(data, tensorConfig);\n    } else {\n      throw new Error('Input data provided is not supported - aborted tensor creation');\n    }\n  }\n\n  toDataURL(options?: TensorToImageDataOptions): string {\n    const canvas = document.createElement('canvas');\n    canvas.width = this.dims[3];\n    canvas.height = this.dims[2];\n    const pixels2DContext = canvas.getContext('2d');\n\n    if (pixels2DContext != null) {\n      // Default values for height and width & format\n      let width: number;\n      let height: number;\n      if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {\n        width = this.dims[2];\n        height = this.dims[3];\n      } else {  // Default layout is NCWH\n        width = this.dims[3];\n        height = this.dims[2];\n      }\n\n      const inputformat = options?.format !== undefined ? options.format : 'RGB';\n\n      const norm = options?.norm;\n      let normMean: [number, number, number, number];\n      let normBias: [number, number, number, number];\n      if (norm === undefined || norm.mean === undefined) {\n        normMean = [255, 255, 255, 255];\n      } else {\n        if (typeof (norm.mean) === 'number') {\n          normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n        } else {\n          normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];\n          if (norm.mean[3] !== undefined) {\n            normMean[3] = norm.mean[3];\n          }\n        }\n      }\n      if (norm === undefined || norm.bias === undefined) {\n        normBias = [0, 0, 0, 0];\n      } else {\n        if (typeof (norm.bias) === 'number') {\n          normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n        } else {\n          normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];\n          if (norm.bias[3] !== undefined) {\n            normBias[3] = norm.bias[3];\n          }\n        }\n      }\n\n      const stride = height * width;\n      // Default pointer assignments\n      let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n\n      // Updating the pointer assignments based on the input image format\n      if (inputformat === 'RGBA') {\n        rTensorPointer = 0;\n        gTensorPointer = stride;\n        bTensorPointer = stride * 2;\n        aTensorPointer = stride * 3;\n      } else if (inputformat === 'RGB') {\n        rTensorPointer = 0;\n        gTensorPointer = stride;\n        bTensorPointer = stride * 2;\n      } else if (inputformat === 'RBG') {\n        rTensorPointer = 0;\n        bTensorPointer = stride;\n        gTensorPointer = stride * 2;\n      }\n\n      for (let i = 0; i < height; i++) {\n        for (let j = 0; j < width; j++) {\n          const R = ((this.data[rTensorPointer++] as number) - normBias[0]) * normMean[0];  // R value\n          const G = ((this.data[gTensorPointer++] as number) - normBias[1]) * normMean[1];  // G value\n          const B = ((this.data[bTensorPointer++] as number) - normBias[2]) * normMean[2];  // B value\n          const A = aTensorPointer === -1 ?\n              255 :\n              ((this.data[aTensorPointer++] as number) - normBias[3]) * normMean[3];  // A value\n          // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n          pixels2DContext.fillStyle = 'rgba(' + R + ',' + G + ',' + B + ',' + A + ')';\n          pixels2DContext.fillRect(j, i, 1, 1);\n        }\n      }\n      return canvas.toDataURL();\n    } else {\n      throw new Error('Can not access image data');\n    }\n  }\n\n  toImageData(options?: TensorToImageDataOptions): ImageData {\n    const pixels2DContext = document.createElement('canvas').getContext('2d');\n    let image: ImageData;\n    if (pixels2DContext != null) {\n      // Default values for height and width & format\n      let width: number;\n      let height: number;\n      let channels: number;\n      if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {\n        width = this.dims[2];\n        height = this.dims[1];\n        channels = this.dims[3];\n      } else {  // Default layout is NCWH\n        width = this.dims[3];\n        height = this.dims[2];\n        channels = this.dims[1];\n      }\n      const inputformat = options !== undefined ? (options.format !== undefined ? options.format : 'RGB') : 'RGB';\n\n      const norm = options?.norm;\n      let normMean: [number, number, number, number];\n      let normBias: [number, number, number, number];\n      if (norm === undefined || norm.mean === undefined) {\n        normMean = [255, 255, 255, 255];\n      } else {\n        if (typeof (norm.mean) === 'number') {\n          normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n        } else {\n          normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];\n          if (norm.mean[3] !== undefined) {\n            normMean[3] = norm.mean[3];\n          }\n        }\n      }\n      if (norm === undefined || norm.bias === undefined) {\n        normBias = [0, 0, 0, 0];\n      } else {\n        if (typeof (norm.bias) === 'number') {\n          normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n        } else {\n          normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];\n          if (norm.bias[3] !== undefined) {\n            normBias[3] = norm.bias[3];\n          }\n        }\n      }\n\n      const stride = height * width;\n      if (options !== undefined) {\n        if (options.height !== undefined && options.height !== height) {\n          throw new Error('Image output config height doesn\\'t match tensor height');\n        }\n        if (options.width !== undefined && options.width !== width) {\n          throw new Error('Image output config width doesn\\'t match tensor width');\n        }\n        if (options.format !== undefined && (channels === 4 && options.format !== 'RGBA') ||\n            (channels === 3 && (options.format !== 'RGB' && options.format !== 'BGR'))) {\n          throw new Error('Tensor format doesn\\'t match input tensor dims');\n        }\n      }\n\n      // Default pointer assignments\n      const step = 4;\n      let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n      let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n\n      // Updating the pointer assignments based on the input image format\n      if (inputformat === 'RGBA') {\n        rTensorPointer = 0;\n        gTensorPointer = stride;\n        bTensorPointer = stride * 2;\n        aTensorPointer = stride * 3;\n      } else if (inputformat === 'RGB') {\n        rTensorPointer = 0;\n        gTensorPointer = stride;\n        bTensorPointer = stride * 2;\n      } else if (inputformat === 'RBG') {\n        rTensorPointer = 0;\n        bTensorPointer = stride;\n        gTensorPointer = stride * 2;\n      }\n\n      image = pixels2DContext.createImageData(width, height);\n\n      for (let i = 0; i < height * width;\n           rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {\n        image.data[rImagePointer] = ((this.data[rTensorPointer++] as number) - normBias[0]) * normMean[0];  // R value\n        image.data[gImagePointer] = ((this.data[gTensorPointer++] as number) - normBias[1]) * normMean[1];  // G value\n        image.data[bImagePointer] = ((this.data[bTensorPointer++] as number) - normBias[2]) * normMean[2];  // B value\n        image.data[aImagePointer] = aTensorPointer === -1 ?\n            255 :\n            ((this.data[aTensorPointer++] as number) - normBias[3]) * normMean[3];  // A value\n      }\n\n    } else {\n      throw new Error('Can not access image data');\n    }\n    return image;\n  }\n\n  // #region fields\n  readonly dims: readonly number[];\n  readonly type: TensorType;\n  readonly data: TensorDataType;\n  readonly size: number;\n  // #endregion\n\n  // #region tensor utilities\n  reshape(dims: readonly number[]): Tensor {\n    return new Tensor(this.type, this.data, dims);\n  }\n  // #endregion\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor as TensorImpl} from './tensor-impl';\nimport {TypedTensorUtils} from './tensor-utils';\n\n/* eslint-disable @typescript-eslint/no-redeclare */\n\n/**\n * represent a basic tensor with specified dimensions and data type.\n */\ninterface TypedTensorBase<T extends Tensor.Type> {\n  /**\n   * Get the dimensions of the tensor.\n   */\n  readonly dims: readonly number[];\n  /**\n   * Get the data type of the tensor.\n   */\n  readonly type: T;\n  /**\n   * Get the buffer data of the tensor.\n   */\n  readonly data: Tensor.DataTypeMap[T];\n}\n\nexport declare namespace Tensor {\n  interface DataTypeMap {\n    float32: Float32Array;\n    uint8: Uint8Array;\n    int8: Int8Array;\n    uint16: Uint16Array;\n    int16: Int16Array;\n    int32: Int32Array;\n    int64: BigInt64Array;\n    string: string[];\n    bool: Uint8Array;\n    float16: never;  // hold on using Uint16Array before we have a concrete solution for float 16\n    float64: Float64Array;\n    uint32: Uint32Array;\n    uint64: BigUint64Array;\n    // complex64: never;\n    // complex128: never;\n    // bfloat16: never;\n  }\n\n  interface ElementTypeMap {\n    float32: number;\n    uint8: number;\n    int8: number;\n    uint16: number;\n    int16: number;\n    int32: number;\n    int64: bigint;\n    string: string;\n    bool: boolean;\n    float16: never;  // hold on before we have a concret solution for float 16\n    float64: number;\n    uint32: number;\n    uint64: bigint;\n    // complex64: never;\n    // complex128: never;\n    // bfloat16: never;\n  }\n\n  type DataType = DataTypeMap[Type];\n  type ElementType = ElementTypeMap[Type];\n\n  /**\n   * represent the data type of a tensor\n   */\n  export type Type = keyof DataTypeMap;\n}\n\n/**\n * Represent multi-dimensional arrays to feed to or fetch from model inferencing.\n */\nexport interface TypedTensor<T extends Tensor.Type> extends TypedTensorBase<T>, TypedTensorUtils<T> {}\n/**\n * Represent multi-dimensional arrays to feed to or fetch from model inferencing.\n */\nexport interface Tensor extends TypedTensorBase<Tensor.Type>, TypedTensorUtils<Tensor.Type> {}\n\nexport interface TensorConstructor {\n  // #region specify element type\n  /**\n   * Construct a new string tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(type: 'string', data: Tensor.DataTypeMap['string']|readonly string[],\n      dims?: readonly number[]): TypedTensor<'string'>;\n\n  /**\n   * Construct a new bool tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(type: 'bool', data: Tensor.DataTypeMap['bool']|readonly boolean[], dims?: readonly number[]): TypedTensor<'bool'>;\n\n  /**\n   * Construct a new numeric tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new<T extends Exclude<Tensor.Type, 'string'|'bool'>>(\n      type: T, data: Tensor.DataTypeMap[T]|readonly number[], dims?: readonly number[]): TypedTensor<T>;\n  // #endregion\n\n  // #region infer element types\n\n  /**\n   * Construct a new float32 tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: Float32Array, dims?: readonly number[]): TypedTensor<'float32'>;\n\n  /**\n   * Construct a new int8 tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: Int8Array, dims?: readonly number[]): TypedTensor<'int8'>;\n\n  /**\n   * Construct a new uint8 tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: Uint8Array, dims?: readonly number[]): TypedTensor<'uint8'>;\n\n  /**\n   * Construct a new uint16 tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: Uint16Array, dims?: readonly number[]): TypedTensor<'uint16'>;\n\n  /**\n   * Construct a new int16 tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: Int16Array, dims?: readonly number[]): TypedTensor<'int16'>;\n\n  /**\n   * Construct a new int32 tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: Int32Array, dims?: readonly number[]): TypedTensor<'int32'>;\n\n  /**\n   * Construct a new int64 tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: BigInt64Array, dims?: readonly number[]): TypedTensor<'int64'>;\n\n  /**\n   * Construct a new string tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: readonly string[], dims?: readonly number[]): TypedTensor<'string'>;\n\n  /**\n   * Construct a new bool tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: readonly boolean[], dims?: readonly number[]): TypedTensor<'bool'>;\n\n  /**\n   * Construct a new float64 tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: Float64Array, dims?: readonly number[]): TypedTensor<'float64'>;\n\n  /**\n   * Construct a new uint32 tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: Uint32Array, dims?: readonly number[]): TypedTensor<'uint32'>;\n\n  /**\n   * Construct a new uint64 tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: BigUint64Array, dims?: readonly number[]): TypedTensor<'uint64'>;\n\n  // #endregion\n\n  // #region fall back to non-generic tensor type declaration\n\n  /**\n   * Construct a new tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(type: Tensor.Type, data: Tensor.DataType|readonly number[]|readonly boolean[], dims?: readonly number[]): Tensor;\n\n  /**\n   * Construct a new tensor object from the given data and dims.\n   *\n   * @param data - Specify the tensor data\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new(data: Tensor.DataType, dims?: readonly number[]): Tensor;\n  // #endregion\n}\n\n/**\n * Specify the image format. Assume 'RGBA' if omitted.\n */\nexport type ImageFormat = 'RGB'|'RGBA'|'BGR'|'RBG';\n\n/**\n * Describes Tensor configuration to an image data.\n */\nexport interface TensorToImageDataOptions {\n  /**\n   * Describes Tensor channels order.\n   */\n  format?: ImageFormat;\n  /**\n   * Tensor channel layout - default is 'NHWC'\n   */\n  tensorLayout?: 'NHWC'|'NCHW';\n  /**\n   * Describes Tensor Height - can be accessed via tensor dimensions as well\n   */\n  height?: number;\n  /**\n   * Describes Tensor Width - can be accessed via tensor dimensions as well\n   */\n  width?: number;\n  /**\n   * Describes normalization parameters to ImageData conversion from tensor - default values - Bias: 0, Mean: 255\n   * Supports computation base on single parameter (extended to all channels) up to value per channel\n   * Example - tesnor.toImageData({norm:{bias:[2/5,3/6,9/17,5/8],mean:[5,6,17,8]}})\n   */\n  norm?: {\n    bias?: number|[number, number, number]|[number, number, number, number];\n    mean?: number | [number, number, number] | [number, number, number, number];\n  };\n}\n/**\n * Describes Tensor and Image configuration to an image data.\n */\nexport interface TensorFromImageOptions {\n  /**\n   * Describes image data format - will be used only in the case of ImageBitMap\n   */\n  bitmapFormat?: ImageFormat;\n  /**\n   * Describes Tensor channels order - can differ from original image\n   */\n  tensorFormat?: ImageFormat;\n  /**\n   * Tensor data type - default is 'float32'\n   */\n  dataType?: 'float32'|'uint8';\n  /**\n   * Tensor channel layout - default is 'NCHW' - TODO: add support for 'NHWC'\n   */\n  tensorLayout?: 'NHWC'|'NCHW';\n  /**\n   * Describes Image Height - Required only in the case of ImageBitMap\n   */\n  height?: number;\n  /**\n   * Describes Image Width - Required only in the case of ImageBitMap\n   */\n  width?: number;\n  /**\n   * Describes resized height - can be accessed via tensor dimensions as well\n   */\n  resizedHeight?: number;\n  /**\n   * Describes resized width - can be accessed via tensor dimensions as well\n   */\n  resizedWidth?: number;\n  /**\n   * Describes normalization parameters to tensor conversion from image data - default values - Bias: 0, Mean: 255\n   * Supports computation base on single parameter (extended to all channels) up to value per channel\n   * Example - Tensor.fromImage(img, {norm:{bias:[2,3,9,5],mean:[5,6,17,8]}});\n   */\n  norm?: {\n    bias?: number|[number, number, number]|[number, number, number, number];\n    mean?: number | [number, number, number] | [number, number, number, number];\n  };\n}\nexport interface TensorFactory {\n  /**\n   * create a tensor from image object - HTMLImageElement, ImageData, ImageBitmap, URL\n   *\n   * @param imageData - {ImageData} - composed of: Uint8ClampedArray, width. height - uses known pixel format RGBA\n   * @param options - Optional - Interface describing input image & output tensor -\n   * Input Defaults: RGBA, 3 channels, 0-255, NHWC - Output Defaults: same as input parameters\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(imageData: ImageData, options?: TensorFromImageOptions): Promise<Tensor>;\n\n  /**\n   * create a tensor from image object - HTMLImageElement, ImageData, ImageBitmap, URL\n   *\n   * @param imageElement - {HTMLImageElement} - since the data is stored as ImageData no need for format parameter\n   * @param options - Optional - Interface describing input image & output tensor -\n   * Input Defaults: RGBA, 3 channels, 0-255, NHWC - Output Defaults: same as input parameters\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(imageElement: HTMLImageElement, options?: TensorFromImageOptions): Promise<Tensor>;\n\n  /**\n   * create a tensor from image object - HTMLImageElement, ImageData, ImageBitmap, URL\n   *\n   * @param urlSource - {string} - Assuming the string is a URL to an image or Data URL\n   * @param options - Optional - Interface describing input image & output tensor -\n   * Input Defaults: RGBA, 3 channels, 0-255, NHWC - Output Defaults: same as input parameters\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(urlSource: string, options?: TensorFromImageOptions): Promise<Tensor>;\n\n  /**\n   * create a tensor from image object - HTMLImageElement, ImageData, ImageBitmap, URL\n   *\n   * @param bitMap - {ImageBitmap} - since the data is stored as ImageData no need for format parameter\n   * @param options - NOT Optional - Interface describing input image & output tensor -\n   * Output Defaults: same as input parameters\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(bitmap: ImageBitmap, options: TensorFromImageOptions): Promise<Tensor>;\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Tensor = TensorImpl as TensorConstructor;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {SessionHandler} from './backend';\nimport {resolveBackend} from './backend-impl';\nimport {InferenceSession as InferenceSessionInterface} from './inference-session';\nimport {OnnxValue} from './onnx-value';\nimport {Tensor} from './tensor';\n\ntype SessionOptions = InferenceSessionInterface.SessionOptions;\ntype RunOptions = InferenceSessionInterface.RunOptions;\ntype FeedsType = InferenceSessionInterface.FeedsType;\ntype FetchesType = InferenceSessionInterface.FetchesType;\ntype ReturnType = InferenceSessionInterface.ReturnType;\n\nexport class InferenceSession implements InferenceSessionInterface {\n  private constructor(handler: SessionHandler) {\n    this.handler = handler;\n  }\n  run(feeds: FeedsType, options?: RunOptions): Promise<ReturnType>;\n  run(feeds: FeedsType, fetches: FetchesType, options?: RunOptions): Promise<ReturnType>;\n  async run(feeds: FeedsType, arg1?: FetchesType|RunOptions, arg2?: RunOptions): Promise<ReturnType> {\n    const fetches: {[name: string]: OnnxValue|null} = {};\n    let options: RunOptions = {};\n    // check inputs\n    if (typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {\n      throw new TypeError(\n          '\\'feeds\\' must be an object that use input names as keys and OnnxValue as corresponding values.');\n    }\n\n    let isFetchesEmpty = true;\n    // determine which override is being used\n    if (typeof arg1 === 'object') {\n      if (arg1 === null) {\n        throw new TypeError('Unexpected argument[1]: cannot be null.');\n      }\n      if (arg1 instanceof Tensor) {\n        throw new TypeError('\\'fetches\\' cannot be a Tensor');\n      }\n\n      if (Array.isArray(arg1)) {\n        if (arg1.length === 0) {\n          throw new TypeError('\\'fetches\\' cannot be an empty array.');\n        }\n        isFetchesEmpty = false;\n        // output names\n        for (const name of arg1) {\n          if (typeof name !== 'string') {\n            throw new TypeError('\\'fetches\\' must be a string array or an object.');\n          }\n          if (this.outputNames.indexOf(name) === -1) {\n            throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n          }\n          fetches[name] = null;\n        }\n\n        if (typeof arg2 === 'object' && arg2 !== null) {\n          options = arg2;\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError('\\'options\\' must be an object.');\n        }\n      } else {\n        // decide whether arg1 is fetches or options\n        // if any output name is present and its value is valid OnnxValue, we consider it fetches\n        let isFetches = false;\n        const arg1Keys = Object.getOwnPropertyNames(arg1);\n        for (const name of this.outputNames) {\n          if (arg1Keys.indexOf(name) !== -1) {\n            const v = (arg1 as InferenceSessionInterface.NullableOnnxValueMapType)[name];\n            if (v === null || v instanceof Tensor) {\n              isFetches = true;\n              isFetchesEmpty = false;\n              fetches[name] = v;\n            }\n          }\n        }\n\n        if (isFetches) {\n          if (typeof arg2 === 'object' && arg2 !== null) {\n            options = arg2;\n          } else if (typeof arg2 !== 'undefined') {\n            throw new TypeError('\\'options\\' must be an object.');\n          }\n        } else {\n          options = arg1 as RunOptions;\n        }\n      }\n    } else if (typeof arg1 !== 'undefined') {\n      throw new TypeError('Unexpected argument[1]: must be \\'fetches\\' or \\'options\\'.');\n    }\n\n    // check if all inputs are in feed\n    for (const name of this.inputNames) {\n      if (typeof feeds[name] === 'undefined') {\n        throw new Error(`input '${name}' is missing in 'feeds'.`);\n      }\n    }\n\n    // if no fetches is specified, we use the full output names list\n    if (isFetchesEmpty) {\n      for (const name of this.outputNames) {\n        fetches[name] = null;\n      }\n    }\n\n    // feeds, fetches and options are prepared\n\n    const results = await this.handler.run(feeds, fetches, options);\n    const returnValue: {[name: string]: OnnxValue} = {};\n    for (const key in results) {\n      if (Object.hasOwnProperty.call(results, key)) {\n        returnValue[key] = new Tensor(results[key].type, results[key].data, results[key].dims);\n      }\n    }\n    return returnValue;\n  }\n\n  static create(path: string, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static create(buffer: ArrayBufferLike, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static create(buffer: ArrayBufferLike, byteOffset: number, byteLength?: number, options?: SessionOptions):\n      Promise<InferenceSessionInterface>;\n  static create(buffer: Uint8Array, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static async create(\n      arg0: string|ArrayBufferLike|Uint8Array, arg1?: SessionOptions|number, arg2?: number,\n      arg3?: SessionOptions): Promise<InferenceSessionInterface> {\n    // either load from a file or buffer\n    let filePathOrUint8Array: string|Uint8Array;\n    let options: SessionOptions = {};\n\n    if (typeof arg0 === 'string') {\n      filePathOrUint8Array = arg0;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n    } else if (arg0 instanceof Uint8Array) {\n      filePathOrUint8Array = arg0;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n    } else if (\n        arg0 instanceof ArrayBuffer ||\n        (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)) {\n      const buffer = arg0;\n      let byteOffset = 0;\n      let byteLength = arg0.byteLength;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 === 'number') {\n        byteOffset = arg1;\n        if (!Number.isSafeInteger(byteOffset)) {\n          throw new RangeError('\\'byteOffset\\' must be an integer.');\n        }\n        if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n          throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n        }\n        byteLength = arg0.byteLength - byteOffset;\n        if (typeof arg2 === 'number') {\n          byteLength = arg2;\n          if (!Number.isSafeInteger(byteLength)) {\n            throw new RangeError('\\'byteLength\\' must be an integer.');\n          }\n          if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n            throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n          }\n          if (typeof arg3 === 'object' && arg3 !== null) {\n            options = arg3;\n          } else if (typeof arg3 !== 'undefined') {\n            throw new TypeError('\\'options\\' must be an object.');\n          }\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError('\\'byteLength\\' must be a number.');\n        }\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n      filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n    } else {\n      throw new TypeError('Unexpected argument[0]: must be \\'path\\' or \\'buffer\\'.');\n    }\n\n    // get backend hints\n    const eps = options.executionProviders || [];\n    const backendHints = eps.map(i => typeof i === 'string' ? i : i.name);\n    const backend = await resolveBackend(backendHints);\n    const handler = await backend.createSessionHandler(filePathOrUint8Array, options);\n    return new InferenceSession(handler);\n  }\n\n  startProfiling(): void {\n    this.handler.startProfiling();\n  }\n  endProfiling(): void {\n    this.handler.endProfiling();\n  }\n\n  get inputNames(): readonly string[] {\n    return this.handler.inputNames;\n  }\n  get outputNames(): readonly string[] {\n    return this.handler.outputNames;\n  }\n\n  private handler: SessionHandler;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceSession as InferenceSessionImpl} from './inference-session-impl';\nimport {OnnxValue} from './onnx-value';\n\n/* eslint-disable @typescript-eslint/no-redeclare */\n\nexport declare namespace InferenceSession {\n  // #region input/output types\n\n  type OnnxValueMapType = {readonly [name: string]: OnnxValue};\n  type NullableOnnxValueMapType = {readonly [name: string]: OnnxValue | null};\n\n  /**\n   * A feeds (model inputs) is an object that uses input names as keys and OnnxValue as corresponding values.\n   */\n  type FeedsType = OnnxValueMapType;\n\n  /**\n   * A fetches (model outputs) could be one of the following:\n   *\n   * - Omitted. Use model's output names definition.\n   * - An array of string indicating the output names.\n   * - An object that use output names as keys and OnnxValue or null as corresponding values.\n   *\n   * @remark\n   * different from input argument, in output, OnnxValue is optional. If an OnnxValue is present it will be\n   * used as a pre-allocated value by the inference engine; if omitted, inference engine will allocate buffer\n   * internally.\n   */\n  type FetchesType = readonly string[]|NullableOnnxValueMapType;\n\n  /**\n   * A inferencing return type is an object that uses output names as keys and OnnxValue as corresponding values.\n   */\n  type ReturnType = OnnxValueMapType;\n\n  // #endregion\n\n  // #region session options\n\n  /**\n   * A set of configurations for session behavior.\n   */\n  export interface SessionOptions {\n    /**\n     * An array of execution provider options.\n     *\n     * An execution provider option can be a string indicating the name of the execution provider,\n     * or an object of corresponding type.\n     */\n    executionProviders?: readonly ExecutionProviderConfig[];\n\n    /**\n     * The intra OP threads number.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native).\n     */\n    intraOpNumThreads?: number;\n\n    /**\n     * The inter OP threads number.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native).\n     */\n    interOpNumThreads?: number;\n\n    /**\n     * The optimization level.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    graphOptimizationLevel?: 'disabled'|'basic'|'extended'|'all';\n\n    /**\n     * Whether enable CPU memory arena.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    enableCpuMemArena?: boolean;\n\n    /**\n     * Whether enable memory pattern.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    enableMemPattern?: boolean;\n\n    /**\n     * Execution mode.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    executionMode?: 'sequential'|'parallel';\n\n    /**\n     * Optimized model file path.\n     *\n     * If this setting is specified, the optimized model will be dumped. In browser, a blob will be created\n     * with a pop-up window.\n     */\n    optimizedModelFilePath?: string;\n\n    /**\n     * Wether enable profiling.\n     *\n     * This setting is a placeholder for a future use.\n     */\n    enableProfiling?: boolean;\n\n    /**\n     * File prefix for profiling.\n     *\n     * This setting is a placeholder for a future use.\n     */\n    profileFilePrefix?: string;\n\n    /**\n     * Log ID.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    logId?: string;\n\n    /**\n     * Log severity level. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/common/logging/severity.h\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    logSeverityLevel?: 0|1|2|3|4;\n\n    /**\n     * Log verbosity level.\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     */\n    logVerbosityLevel?: number;\n\n    /**\n     * Store configurations for a session. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/session/\n     * onnxruntime_session_options_config_keys.h\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     *\n     * @example\n     * ```js\n     * extra: {\n     *   session: {\n     *     set_denormal_as_zero: \"1\",\n     *     disable_prepacking: \"1\"\n     *   },\n     *   optimization: {\n     *     enable_gelu_approximation: \"1\"\n     *   }\n     * }\n     * ```\n     */\n    extra?: Record<string, unknown>;\n  }\n\n  // #region execution providers\n\n  // Currently, we have the following backends to support execution providers:\n  // Backend Node.js binding: supports 'cpu' and 'cuda'.\n  // Backend WebAssembly: supports 'cpu', 'wasm' and 'xnnpack'.\n  // Backend ONNX.js: supports 'webgl'.\n  interface ExecutionProviderOptionMap {\n    cpu: CpuExecutionProviderOption;\n    cuda: CudaExecutionProviderOption;\n    wasm: WebAssemblyExecutionProviderOption;\n    webgl: WebGLExecutionProviderOption;\n    xnnpack: XnnpackExecutionProviderOption;\n  }\n\n  type ExecutionProviderName = keyof ExecutionProviderOptionMap;\n  type ExecutionProviderConfig =\n      ExecutionProviderOptionMap[ExecutionProviderName]|ExecutionProviderOption|ExecutionProviderName|string;\n\n  export interface ExecutionProviderOption {\n    readonly name: string;\n  }\n  export interface CpuExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'cpu';\n    useArena?: boolean;\n  }\n  export interface CudaExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'cuda';\n    deviceId?: number;\n  }\n  export interface WebAssemblyExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'wasm';\n  }\n  export interface WebGLExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'webgl';\n    // TODO: add flags\n  }\n  export interface XnnpackExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'xnnpack';\n  }\n  // #endregion\n\n  // #endregion\n\n  // #region run options\n\n  /**\n   * A set of configurations for inference run behavior\n   */\n  export interface RunOptions {\n    /**\n     * Log severity level. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/common/logging/severity.h\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    logSeverityLevel?: 0|1|2|3|4;\n\n    /**\n     * Log verbosity level.\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     */\n    logVerbosityLevel?: number;\n\n    /**\n     * Terminate all incomplete OrtRun calls as soon as possible if true\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     */\n    terminate?: boolean;\n\n    /**\n     * A tag for the Run() calls using this\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    tag?: string;\n\n    /**\n     * Set a single run configuration entry. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/session/\n     * onnxruntime_run_options_config_keys.h\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     *\n     * @example\n     *\n     * ```js\n     * extra: {\n     *   memory: {\n     *     enable_memory_arena_shrinkage: \"1\",\n     *   }\n     * }\n     * ```\n     */\n    extra?: Record<string, unknown>;\n  }\n\n  // #endregion\n\n  // #region value metadata\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface ValueMetadata {\n    // TBD\n  }\n\n  // #endregion\n}\n\n/**\n * Represent a runtime instance of an ONNX model.\n */\nexport interface InferenceSession {\n  // #region run()\n\n  /**\n   * Execute the model asynchronously with the given feeds and options.\n   *\n   * @param feeds - Representation of the model input. See type description of `InferenceSession.InputType` for detail.\n   * @param options - Optional. A set of options that controls the behavior of model inference.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding values.\n   */\n  run(feeds: InferenceSession.FeedsType, options?: InferenceSession.RunOptions): Promise<InferenceSession.ReturnType>;\n\n  /**\n   * Execute the model asynchronously with the given feeds, fetches and options.\n   *\n   * @param feeds - Representation of the model input. See type description of `InferenceSession.InputType` for detail.\n   * @param fetches - Representation of the model output. See type description of `InferenceSession.OutputType` for\n   * detail.\n   * @param options - Optional. A set of options that controls the behavior of model inference.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding values.\n   */\n  run(feeds: InferenceSession.FeedsType, fetches: InferenceSession.FetchesType,\n      options?: InferenceSession.RunOptions): Promise<InferenceSession.ReturnType>;\n\n  // #endregion\n\n  // #region profiling\n\n  /**\n   * Start profiling.\n   */\n  startProfiling(): void;\n\n  /**\n   * End profiling.\n   */\n  endProfiling(): void;\n\n  // #endregion\n\n  // #region metadata\n\n  /**\n   * Get input names of the loaded model.\n   */\n  readonly inputNames: readonly string[];\n\n  /**\n   * Get output names of the loaded model.\n   */\n  readonly outputNames: readonly string[];\n\n  // /**\n  //  * Get input metadata of the loaded model.\n  //  */\n  // readonly inputMetadata: ReadonlyArray<Readonly<InferenceSession.ValueMetadata>>;\n\n  // /**\n  //  * Get output metadata of the loaded model.\n  //  */\n  // readonly outputMetadata: ReadonlyArray<Readonly<InferenceSession.ValueMetadata>>;\n\n  // #endregion\n}\n\nexport interface InferenceSessionFactory {\n  // #region create()\n\n  /**\n   * Create a new inference session and load model asynchronously from an ONNX model file.\n   *\n   * @param uri - The URI or file path of the model to load.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(uri: string, options?: InferenceSession.SessionOptions): Promise<InferenceSession>;\n\n  /**\n   * Create a new inference session and load model asynchronously from an array bufer.\n   *\n   * @param buffer - An ArrayBuffer representation of an ONNX model.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(buffer: ArrayBufferLike, options?: InferenceSession.SessionOptions): Promise<InferenceSession>;\n\n  /**\n   * Create a new inference session and load model asynchronously from segment of an array bufer.\n   *\n   * @param buffer - An ArrayBuffer representation of an ONNX model.\n   * @param byteOffset - The beginning of the specified portion of the array buffer.\n   * @param byteLength - The length in bytes of the array buffer.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(buffer: ArrayBufferLike, byteOffset: number, byteLength?: number, options?: InferenceSession.SessionOptions):\n      Promise<InferenceSession>;\n\n  /**\n   * Create a new inference session and load model asynchronously from a Uint8Array.\n   *\n   * @param buffer - A Uint8Array representation of an ONNX model.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(buffer: Uint8Array, options?: InferenceSession.SessionOptions): Promise<InferenceSession>;\n\n  // #endregion\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const InferenceSession: InferenceSessionFactory = InferenceSessionImpl;\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","backends","backendsSortedByPriority","registerBackend","name","backend","priority","init","createSessionHandler","TypeError","currentBackend","undefined","Error","i","indexOf","splice","length","push","env","constructor","this","wasm","webgl","webgpu","logLevelInternal","logLevel","NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP","Map","Float32Array","Uint8Array","Int8Array","Uint16Array","Int16Array","Int32Array","Float64Array","Uint32Array","NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP","isBigIntChecked","Tensor","arg0","arg1","arg2","type","data","dims","isBigInt64ArrayAvailable","BigInt64Array","from","isBigUint64ArrayAvailable","BigUint64Array","set","checkBigInt","Array","isArray","typedArrayConstructor","firstElementType","mappedType","size","dim","Number","isSafeInteger","RangeError","calculateSize","static","buffer","options","height","width","tensorLayout","norm","mean","bias","normMean","normBias","inputformat","bitmapFormat","outputformat","tensorFormat","stride","float32Data","step","rImagePointer","gImagePointer","bImagePointer","aImagePointer","rTensorPointer","gTensorPointer","bTensorPointer","aTensorPointer","image","isHTMLImageEle","HTMLImageElement","isImageDataEle","ImageData","isImageBitmap","ImageBitmap","isString","tensorConfig","canvas","document","createElement","pixels2DContext","getContext","resizedHeight","resizedWidth","drawImage","getImageData","bufferToTensor","Promise","resolve","reject","context","newImage","Image","crossOrigin","src","onload","img","format","tempCanvas","putImageData","toDataURL","j","R","G","B","A","fillStyle","fillRect","toImageData","channels","createImageData","reshape","InferenceSession","handler","async","feeds","fetches","isFetchesEmpty","outputNames","isFetches","arg1Keys","getOwnPropertyNames","v","inputNames","results","run","returnValue","arg3","filePathOrUint8Array","ArrayBuffer","SharedArrayBuffer","byteOffset","byteLength","backendHints","executionProviders","map","backendNames","errors","backendName","backendInfo","initialized","aborted","isInitializing","initPromise","e","err","join","resolveBackend","startProfiling","endProfiling"],"sourceRoot":""}