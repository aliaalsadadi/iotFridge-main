/*!
 * ONNX Runtime Common v1.15.1
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.ort=e():t.ort=e()}(self,(()=>(()=>{"use strict";var t={d:(e,n)=>{for(var r in n)t.o(n,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{InferenceSession:()=>u,Tensor:()=>h,env:()=>o,registerBackend:()=>i});const n={},r=[],i=(t,e,i)=>{if(!e||"function"!=typeof e.init||"function"!=typeof e.createSessionHandler)throw new TypeError("not a valid backend");{const o=n[t];if(void 0===o)n[t]={backend:e,priority:i};else{if(o.priority>i)return;if(o.priority===i&&o.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${i}`)}if(i>=0){const e=r.indexOf(t);-1!==e&&r.splice(e,1);for(let e=0;e<r.length;e++)if(n[r[e]].priority<=i)return void r.splice(e,0,t);r.push(t)}}},o=new class{constructor(){this.wasm={},this.webgl={},this.webgpu={},this.logLevelInternal="warning"}set logLevel(t){if(void 0!==t){if("string"!=typeof t||-1===["verbose","info","warning","error","fatal"].indexOf(t))throw new Error(`Unsupported logging level: ${t}`);this.logLevelInternal=t}}get logLevel(){return this.logLevelInternal}};const a=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),s=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let d=!1;class f{constructor(t,e,n){let r,i,o;if((()=>{if(!d){d=!0;const t="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,e="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from;t&&(a.set("int64",BigInt64Array),s.set(BigInt64Array,"int64")),e&&(a.set("uint64",BigUint64Array),s.set(BigUint64Array,"uint64"))}})(),"string"==typeof t)if(r=t,o=n,"string"===t){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");i=e}else{const n=a.get(t);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(e))i=n.from(e);else{if(!(e instanceof n))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);i=e}}else if(o=e,Array.isArray(t)){if(0===t.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const e=typeof t[0];if("string"===e)r="string",i=t;else{if("boolean"!==e)throw new TypeError(`Invalid element type of data array: ${e}.`);r="bool",i=Uint8Array.from(t)}}else{const e=s.get(t.constructor);if(void 0===e)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);r=e,i=t}if(void 0===o)o=[i.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");const f=(t=>{let e=1;for(let n=0;n<t.length;n++){const r=t[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);e*=r}return e})(o);if(f!==i.length)throw new Error(`Tensor's size(${f}) does not match data length(${i.length}).`);this.dims=o,this.type=r,this.data=i,this.size=f}static bufferToTensor(t,e){var n,r,i;if(void 0===t)throw new Error("Image buffer must be defined");if(void 0===e.height||void 0===e.width)throw new Error("Image height and width must be defined");if("NHWC"===e.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:o,width:a}=e,s=null!==(n=e.norm)&&void 0!==n?n:{mean:255,bias:0};let d,h;d="number"==typeof s.mean?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],null!==(r=s.mean[3])&&void 0!==r?r:255],h="number"==typeof s.bias?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],null!==(i=s.bias[3])&&void 0!==i?i:0];const m=void 0!==e.bitmapFormat?e.bitmapFormat:"RGBA",c=void 0!==e.tensorFormat&&void 0!==e.tensorFormat?e.tensorFormat:"RGB",u=o*a,l="RGBA"===c?new Float32Array(4*u):new Float32Array(3*u);let g=4,w=0,y=1,p=2,b=3,v=0,E=u,A=2*u,I=-1;"RGB"===m&&(g=3,w=0,y=1,p=2,b=-1),"RGBA"===c?I=3*u:"RBG"===c?(v=0,A=u,E=2*u):"BGR"===c&&(A=0,E=u,v=2*u);for(let e=0;e<u;e++,w+=g,p+=g,y+=g,b+=g)l[v++]=(t[w]+h[0])/d[0],l[E++]=(t[y]+h[1])/d[1],l[A++]=(t[p]+h[2])/d[2],-1!==I&&-1!==b&&(l[I++]=(t[b]+h[3])/d[3]);return new f("float32",l,"RGBA"===c?[1,4,o,a]:[1,3,o,a])}static fromImage(t,e){return n=this,r=void 0,o=function*(){const n="undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement,r="undefined"!=typeof ImageData&&t instanceof ImageData,i="undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap,o="string"==typeof t;let a,s=null!=e?e:{};if(n){const n=document.createElement("canvas");n.width=t.width,n.height=t.height;const r=n.getContext("2d");if(null==r)throw new Error("Can not access image data");{let n=t.height,i=t.width;if(void 0!==e&&void 0!==e.resizedHeight&&void 0!==e.resizedWidth&&(n=e.resizedHeight,i=e.resizedWidth),void 0!==e){if(s=e,void 0!==e.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(s.tensorFormat="RGBA",void 0!==e.height&&e.height!==n)throw new Error("Image input config height doesn't match HTMLImageElement height");if(s.height=n,void 0!==e.width&&e.width!==i)throw new Error("Image input config width doesn't match HTMLImageElement width");s.width=i}else s.tensorFormat="RGBA",s.height=n,s.width=i;r.drawImage(t,0,0),a=r.getImageData(0,0,i,n).data}}else{if(!r){if(i){if(void 0===e)throw new Error("Please provide image config with format for Imagebitmap");if(void 0!==e.bitmapFormat)throw new Error("Image input config format must be defined for ImageBitmap");const n=document.createElement("canvas").getContext("2d");if(null!=n){const r=t.height,i=t.width;if(n.drawImage(t,0,0,i,r),a=n.getImageData(0,0,i,r).data,void 0!==e){if(void 0!==e.height&&e.height!==r)throw new Error("Image input config height doesn't match ImageBitmap height");if(s.height=r,void 0!==e.width&&e.width!==i)throw new Error("Image input config width doesn't match ImageBitmap width");s.width=i}else s.height=r,s.width=i;return f.bufferToTensor(a,s)}throw new Error("Can not access image data")}if(o)return new Promise(((n,r)=>{const i=document.createElement("canvas"),o=i.getContext("2d");if(!t||!o)return r();const a=new Image;a.crossOrigin="Anonymous",a.src=t,a.onload=()=>{i.width=a.width,i.height=a.height,o.drawImage(a,0,0,i.width,i.height);const t=o.getImageData(0,0,i.width,i.height);if(void 0!==e){if(void 0!==e.height&&e.height!==i.height)throw new Error("Image input config height doesn't match height");if(s.height=i.height,void 0!==e.width&&e.width!==i.width)throw new Error("Image input config width doesn't match width");s.width=i.width}else s.height=i.height,s.width=i.width;n(f.bufferToTensor(t.data,s))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{const n="RGBA";let r,i;if(void 0!==e&&void 0!==e.resizedWidth&&void 0!==e.resizedHeight?(r=e.resizedHeight,i=e.resizedWidth):(r=t.height,i=t.width),void 0!==e){if(s=e,void 0!==e.bitmapFormat&&e.bitmapFormat!==n)throw new Error("Image input config format must be RGBA for ImageData");s.bitmapFormat="RGBA"}else s.bitmapFormat="RGBA";if(s.height=r,s.width=i,void 0!==e){const e=document.createElement("canvas");e.width=i,e.height=r;const n=e.getContext("2d");if(null==n)throw new Error("Can not access image data");n.putImageData(t,0,0),a=n.getImageData(0,0,i,r).data}else a=t.data}}if(void 0!==a)return f.bufferToTensor(a,s);throw new Error("Input data provided is not supported - aborted tensor creation")},new((i=void 0)||(i=Promise))((function(t,e){function a(t){try{d(o.next(t))}catch(t){e(t)}}function s(t){try{d(o.throw(t))}catch(t){e(t)}}function d(e){var n;e.done?t(e.value):(n=e.value,n instanceof i?n:new i((function(t){t(n)}))).then(a,s)}d((o=o.apply(n,r||[])).next())}));var n,r,i,o}toDataURL(t){const e=document.createElement("canvas");e.width=this.dims[3],e.height=this.dims[2];const n=e.getContext("2d");if(null!=n){let r,i;void 0!==(null==t?void 0:t.tensorLayout)&&"NHWC"===t.tensorLayout?(r=this.dims[2],i=this.dims[3]):(r=this.dims[3],i=this.dims[2]);const o=void 0!==(null==t?void 0:t.format)?t.format:"RGB",a=null==t?void 0:t.norm;let s,d;void 0===a||void 0===a.mean?s=[255,255,255,255]:"number"==typeof a.mean?s=[a.mean,a.mean,a.mean,a.mean]:(s=[a.mean[0],a.mean[1],a.mean[2],0],void 0!==a.mean[3]&&(s[3]=a.mean[3])),void 0===a||void 0===a.bias?d=[0,0,0,0]:"number"==typeof a.bias?d=[a.bias,a.bias,a.bias,a.bias]:(d=[a.bias[0],a.bias[1],a.bias[2],0],void 0!==a.bias[3]&&(d[3]=a.bias[3]));const f=i*r;let h=0,m=f,c=2*f,u=-1;"RGBA"===o?(h=0,m=f,c=2*f,u=3*f):"RGB"===o?(h=0,m=f,c=2*f):"RBG"===o&&(h=0,c=f,m=2*f);for(let t=0;t<i;t++)for(let e=0;e<r;e++){const r=(this.data[h++]-d[0])*s[0],i=(this.data[m++]-d[1])*s[1],o=(this.data[c++]-d[2])*s[2],a=-1===u?255:(this.data[u++]-d[3])*s[3];n.fillStyle="rgba("+r+","+i+","+o+","+a+")",n.fillRect(e,t,1,1)}return e.toDataURL()}throw new Error("Can not access image data")}toImageData(t){const e=document.createElement("canvas").getContext("2d");let n;if(null==e)throw new Error("Can not access image data");{let r,i,o;void 0!==(null==t?void 0:t.tensorLayout)&&"NHWC"===t.tensorLayout?(r=this.dims[2],i=this.dims[1],o=this.dims[3]):(r=this.dims[3],i=this.dims[2],o=this.dims[1]);const a=void 0!==t&&void 0!==t.format?t.format:"RGB",s=null==t?void 0:t.norm;let d,f;void 0===s||void 0===s.mean?d=[255,255,255,255]:"number"==typeof s.mean?d=[s.mean,s.mean,s.mean,s.mean]:(d=[s.mean[0],s.mean[1],s.mean[2],255],void 0!==s.mean[3]&&(d[3]=s.mean[3])),void 0===s||void 0===s.bias?f=[0,0,0,0]:"number"==typeof s.bias?f=[s.bias,s.bias,s.bias,s.bias]:(f=[s.bias[0],s.bias[1],s.bias[2],0],void 0!==s.bias[3]&&(f[3]=s.bias[3]));const h=i*r;if(void 0!==t){if(void 0!==t.height&&t.height!==i)throw new Error("Image output config height doesn't match tensor height");if(void 0!==t.width&&t.width!==r)throw new Error("Image output config width doesn't match tensor width");if(void 0!==t.format&&4===o&&"RGBA"!==t.format||3===o&&"RGB"!==t.format&&"BGR"!==t.format)throw new Error("Tensor format doesn't match input tensor dims")}const m=4;let c=0,u=1,l=2,g=3,w=0,y=h,p=2*h,b=-1;"RGBA"===a?(w=0,y=h,p=2*h,b=3*h):"RGB"===a?(w=0,y=h,p=2*h):"RBG"===a&&(w=0,p=h,y=2*h),n=e.createImageData(r,i);for(let t=0;t<i*r;c+=m,u+=m,l+=m,g+=m,t++)n.data[c]=(this.data[w++]-f[0])*d[0],n.data[u]=(this.data[y++]-f[1])*d[1],n.data[l]=(this.data[p++]-f[2])*d[2],n.data[g]=-1===b?255:(this.data[b++]-f[3])*d[3]}return n}reshape(t){return new f(this.type,this.data,t)}}const h=f;var m=function(t,e,n,r){return new(n||(n=Promise))((function(i,o){function a(t){try{d(r.next(t))}catch(t){o(t)}}function s(t){try{d(r.throw(t))}catch(t){o(t)}}function d(t){var e;t.done?i(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(a,s)}d((r=r.apply(t,e||[])).next())}))};class c{constructor(t){this.handler=t}run(t,e,n){return m(this,void 0,void 0,(function*(){const r={};let i={};if("object"!=typeof t||null===t||t instanceof h||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if("object"==typeof e){if(null===e)throw new TypeError("Unexpected argument[1]: cannot be null.");if(e instanceof h)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(e)){if(0===e.length)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(const t of e){if("string"!=typeof t)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(t))throw new RangeError(`'fetches' contains invalid output name: ${t}.`);r[t]=null}if("object"==typeof n&&null!==n)i=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else{let t=!1;const a=Object.getOwnPropertyNames(e);for(const n of this.outputNames)if(-1!==a.indexOf(n)){const i=e[n];(null===i||i instanceof h)&&(t=!0,o=!1,r[n]=i)}if(t){if("object"==typeof n&&null!==n)i=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else i=e}}else if(void 0!==e)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const e of this.inputNames)if(void 0===t[e])throw new Error(`input '${e}' is missing in 'feeds'.`);if(o)for(const t of this.outputNames)r[t]=null;const a=yield this.handler.run(t,r,i),s={};for(const t in a)Object.hasOwnProperty.call(a,t)&&(s[t]=new h(a[t].type,a[t].data,a[t].dims));return s}))}static create(t,e,i,o){return m(this,void 0,void 0,(function*(){let a,s={};if("string"==typeof t){if(a=t,"object"==typeof e&&null!==e)s=e;else if(void 0!==e)throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(a=t,"object"==typeof e&&null!==e)s=e;else if(void 0!==e)throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const n=t;let r=0,d=t.byteLength;if("object"==typeof e&&null!==e)s=e;else if("number"==typeof e){if(r=e,!Number.isSafeInteger(r))throw new RangeError("'byteOffset' must be an integer.");if(r<0||r>=n.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${n.byteLength}).`);if(d=t.byteLength-r,"number"==typeof i){if(d=i,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||r+d>n.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${n.byteLength-r}].`);if("object"==typeof o&&null!==o)s=o;else if(void 0!==o)throw new TypeError("'options' must be an object.")}else if(void 0!==i)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==e)throw new TypeError("'options' must be an object.");a=new Uint8Array(n,r,d)}}const d=(s.executionProviders||[]).map((t=>"string"==typeof t?t:t.name)),f=yield(t=>{return e=void 0,i=void 0,a=function*(){const e=0===t.length?r:t,i=[];for(const t of e){const e=n[t];if(e){if(e.initialized)return e.backend;if(e.aborted)continue;const n=!!e.initPromise;try{return n||(e.initPromise=e.backend.init()),yield e.initPromise,e.initialized=!0,e.backend}catch(r){n||i.push({name:t,err:r}),e.aborted=!0}finally{delete e.initPromise}}}throw new Error(`no available backend found. ERR: ${i.map((t=>`[${t.name}] ${t.err}`)).join(", ")}`)},new((o=void 0)||(o=Promise))((function(t,n){function r(t){try{d(a.next(t))}catch(t){n(t)}}function s(t){try{d(a.throw(t))}catch(t){n(t)}}function d(e){var n;e.done?t(e.value):(n=e.value,n instanceof o?n:new o((function(t){t(n)}))).then(r,s)}d((a=a.apply(e,i||[])).next())}));var e,i,o,a})(d),h=yield f.createSessionHandler(a,s);return new c(h)}))}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const u=c;return e})()));
//# sourceMappingURL=ort-common.es6.min.js.map